<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Face Photo Search</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120'%3E%3Crect width='120' height='120' rx='28' fill='%230f172a'/%3E%3Ccircle cx='44' cy='52' r='12' fill='%23a5b4fc'/%3E%3Ccircle cx='76' cy='52' r='12' fill='%2338bdf8'/%3E%3Cpath d='M38 80c8 6 36 6 44 0' stroke='%236366f1' stroke-width='8' stroke-linecap='round' fill='none'/%3E%3C/svg%3E">
    <style>
        :root {
            --bg: #0f172a;
            --card: #111827;
            --accent: #38bdf8;
            --text: #e5e7eb;
            --muted: #94a3b8;
            --border: #1f2937;
            --green: #22c55e;
        }
        body {
            margin: 0;
            background: radial-gradient(circle at 20% 20%, rgba(56,189,248,0.08), transparent 35%),
                        radial-gradient(circle at 80% 0%, rgba(34,197,94,0.08), transparent 30%),
                        var(--bg);
            color: var(--text);
            font-family: "Inter", "Helvetica Neue", Arial, sans-serif;
            min-height: 100vh;
        }
        header {
            padding: 24px;
            text-align: center;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 28px;
        }
        p.subtitle {
            margin: 0;
            color: var(--muted);
        }
        main {
            max-width: 1100px;
            margin: 0 auto;
            padding: 0 20px 60px;
        }
        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.25);
        }
        .upload-box {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 16px;
        }
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 14px 18px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            background: linear-gradient(120deg, var(--accent), #6366f1);
            color: white;
            font-size: 16px;
            font-weight: 600;
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .hint {
            color: var(--muted);
            font-size: 14px;
        }
        .progress {
            margin-top: 12px;
        }
        progress {
            width: 100%;
            height: 12px;
            border-radius: 8px;
            overflow: hidden;
            background: var(--border);
        }
        progress::-webkit-progress-bar { background: var(--border); }
        progress::-webkit-progress-value { background: var(--accent); }
        .status-line { margin-top: 8px; color: var(--muted); font-size: 14px; }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 16px;
        }
        .person-card {
            border-radius: 14px;
            background: linear-gradient(160deg, rgba(56,189,248,0.08), rgba(99,102,241,0.05));
            border: 1px solid var(--border);
            padding: 12px;
            cursor: pointer;
            transition: transform 0.15s ease, border-color 0.2s ease;
        }
        .person-card:hover { transform: translateY(-4px); border-color: var(--accent); }
        .avatar {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 12px;
            object-fit: cover;
            background: #0b1220;
        }
        .card-title {
            margin: 8px 0 0;
            font-weight: 600;
            color: #fff;
        }
        .card-sub {
            color: var(--muted);
            margin: 2px 0 0;
            font-size: 14px;
        }
        .thumb-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
        }
        .thumb {
            width: 100%;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.1s ease;
        }
        .thumb:hover { transform: scale(1.02); }
        .hidden { display: none; }
        #modal.hidden { display: none !important; }
        .error {
            border: 1px solid #f43f5e;
            background: rgba(244,63,94,0.1);
            color: #fecdd3;
            padding: 12px;
            border-radius: 10px;
            margin-top: 10px;
            white-space: pre-wrap;
        }
        .pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: rgba(34,197,94,0.12);
            color: var(--green);
            padding: 6px 10px;
            border-radius: 999px;
            font-size: 13px;
        }
        @media (max-width: 640px) {
            .upload-box { flex-direction: column; align-items: flex-start; }
        }
        .lang-toggle {
            display: inline-flex;
            gap: 8px;
            margin-top: 8px;
            align-items: center;
        }
        .lang-btn {
            padding: 6px 10px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: rgba(255,255,255,0.05);
            color: var(--text);
            cursor: pointer;
            font-size: 13px;
        }
        .lang-btn.active {
            background: linear-gradient(120deg, var(--accent), #6366f1);
            border-color: #5b7bff;
            color: #fff;
        }
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 20;
        }
        .modal-content {
            position: relative;
        }
        .modal img {
            max-width: 90vw;
            max-height: 90vh;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.45);
        }
        .modal-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            padding: 8px 12px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(120deg, var(--accent), #6366f1);
            color: #fff;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <header>
        <h1 id="titleText">Face Photo Search</h1>
        <p class="subtitle" id="subtitleText">é€‰æ‹©ç…§ç‰‡æ–‡ä»¶å¤¹ â†’ è‡ªåŠ¨è¯†åˆ«äººè„¸ â†’ æŒ‰äººå½’ç±»</p>
        <div class="lang-toggle">
            <button class="lang-btn active" data-lang="en" id="langEn">English</button>
            <button class="lang-btn" data-lang="zh" id="langZh">ä¸­æ–‡</button>
        </div>
    </header>
    <main>
        <section class="card">
            <div class="upload-box">
                <div>
                    <label class="btn" for="folderInput" id="chooseBtn">
                        ğŸ“ é€‰æ‹©ç…§ç‰‡æ–‡ä»¶å¤¹
                    </label>
                    <input id="folderInput" type="file" webkitdirectory directory multiple class="hidden" />
                    <div class="hint" id="browserHint">æ¨èä½¿ç”¨ Chrome / Edge / Safariï¼ˆFirefox å¯èƒ½ä¸æ”¯æŒæ–‡ä»¶å¤¹é€‰æ‹©ï¼‰</div>
                </div>
                <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
                    <button class="btn" id="rebuildBtn" style="background:linear-gradient(120deg,#22c55e,#16a34a);">ğŸ”„ é‡æ–°åˆ†æ</button>
                    <button class="btn" id="clearBtn" style="background:linear-gradient(120deg,#f97316,#ea580c);">ğŸ—‘ï¸ æ¸…ç©ºç¼“å­˜</button>
                    <div class="pill" id="enginePill">å½“å‰å¼•æ“: {{ engine }}</div>
                </div>
            </div>
            {% if error %}
            <div class="error">{{ error }}</div>
            {% endif %}
            <div class="progress">
                <progress id="progressBar" value="0" max="1"></progress>
                <div class="status-line" id="statusText">ç­‰å¾…ä¸Šä¼ ...</div>
            </div>
            <div class="hint" id="folderPath" style="margin-top:6px;">æœªé€‰æ‹©æ–‡ä»¶å¤¹</div>
            <div style="margin-top:12px;display:flex;align-items:center;gap:12px;flex-wrap:wrap;">
                <div class="hint" id="thresholdHint">è°ƒæ•´å½“å‰å¼•æ“çš„é˜ˆå€¼ï¼ˆinsightface è¶Šå¤§è¶Šä¸¥æ ¼ï¼›face_recognition è¶Šå°è¶Šä¸¥æ ¼ï¼‰ï¼š</div>
                <input id="thresholdInput" type="range" min="0.3" max="1.2" step="0.01" value="0.6" style="width:180px;">
                <div class="pill" id="thresholdPill">å½“å‰é˜ˆå€¼: <span id="thresholdValue">0.6</span></div>
                <button class="btn" id="saveThreshold" style="background:linear-gradient(120deg,#6366f1,#8b5cf6);">ğŸ’¾ ä¿å­˜é˜ˆå€¼</button>
            </div>
        </section>

        <section class="card">
            <h2 id="groupsTitle">æ™ºèƒ½åˆé›†</h2>
            <div id="emptyHint" class="hint">è¿˜æ²¡æœ‰æ•°æ®ï¼Œè¯·å…ˆé€‰æ‹©ç…§ç‰‡æ–‡ä»¶å¤¹å¼€å§‹åˆ†æã€‚</div>
            <div id="groupGrid" class="grid hidden"></div>
        </section>

        <section id="detailSection" class="card hidden">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;">
                <h2 id="detailTitle">äººç‰©è¯¦æƒ…</h2>
                <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
                    <button class="btn" id="downloadAllBtn" style="background:linear-gradient(120deg,#0ea5e9,#2563eb);">â¬‡ï¸ ä¸‹è½½å…¨éƒ¨</button>
                    <button class="btn" id="backBtn">â† è¿”å›åˆé›†</button>
                </div>
            </div>
            <div id="detailGrid" class="thumb-grid"></div>
        </section>
    </main>

    <div id="modal" class="modal hidden" style="display:none;" aria-hidden="true">
        <div class="modal-content" id="modalContent">
            <button class="modal-btn" id="downloadPhotoBtn">â¬‡ï¸ ä¸‹è½½</button>
            <img id="modalImg" src="" alt="é¢„è§ˆ">
        </div>
    </div>

    <footer style="max-width:1100px;margin:0 auto 24px;padding:0 20px;color:var(--muted);font-size:13px;text-align:center;">
        <div>ä½œè€…: Def Â· GitHub: <a href="https://github.com/Undefinedefity/Face-Photo-Search" style="color:var(--accent);" target="_blank" rel="noopener">Undefinedefity/Face-Photo-Search</a></div>
        <div>æœ€åæ›´æ–°æ—¶é—´ï¼š2025 å¹´ 12 æœˆ 16 æ—¥</div>
    </footer>

    <div id="floatingStatus" style="position:fixed;right:16px;bottom:16px;z-index:30;min-width:260px;max-width:340px;background:rgba(15,23,42,0.92);border:1px solid var(--border);border-radius:12px;padding:12px;box-shadow:0 10px 30px rgba(0,0,0,0.4);backdrop-filter:blur(6px);">
        <div style="color:var(--muted);font-size:13px;margin-bottom:6px;" id="floatingLabel">Status</div>
        <progress id="floatingProgress" value="0" max="1" style="width:100%;height:10px;border-radius:8px;overflow:hidden;background:var(--border);"></progress>
        <div style="margin-top:6px;color:var(--text);font-size:14px;" id="floatingText">Waiting for upload...</div>
    </div>

    <script>
        const input = document.getElementById('folderInput');
        const progressBar = document.getElementById('progressBar');
        const statusText = document.getElementById('statusText');
        const groupGrid = document.getElementById('groupGrid');
        const emptyHint = document.getElementById('emptyHint');
        const detailSection = document.getElementById('detailSection');
        const detailGrid = document.getElementById('detailGrid');
        const detailTitle = document.getElementById('detailTitle');
        const backBtn = document.getElementById('backBtn');
        const modal = document.getElementById('modal');
        const modalImg = document.getElementById('modalImg');
        const rebuildBtn = document.getElementById('rebuildBtn');
        const thresholdInput = document.getElementById('thresholdInput');
        const thresholdValue = document.getElementById('thresholdValue');
        const folderPathEl = document.getElementById('folderPath');
        const clearBtn = document.getElementById('clearBtn');
        const downloadPhotoBtn = document.getElementById('downloadPhotoBtn');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        const modalContent = document.getElementById('modalContent');
        const floatingStatus = document.getElementById('floatingStatus');
        const floatingText = document.getElementById('floatingText');
        const floatingProgress = document.getElementById('floatingProgress');
        const floatingLabel = document.getElementById('floatingLabel');
        const chooseBtn = document.getElementById('chooseBtn');
        const browserHint = document.getElementById('browserHint');
        const groupsTitle = document.getElementById('groupsTitle');
        const titleText = document.getElementById('titleText');
        const subtitleText = document.getElementById('subtitleText');
        const thresholdHint = document.getElementById('thresholdHint');
        const thresholdPill = document.getElementById('thresholdPill');
        const saveThresholdBtn = document.getElementById('saveThreshold');
        const enginePill = document.getElementById('enginePill');
        const langEnBtn = document.getElementById('langEn');
        const langZhBtn = document.getElementById('langZh');

        let pollTimer = null;
        const initialEngine = '{{ engine }}';
        let currentEngine = initialEngine;
        let currentLang = 'en';
        let currentGroupId = null;
        let currentPhotoId = null;

        const i18n = {
            en: {
                title: 'Face Photo Search',
                subtitle: 'Choose a photo folder â†’ detect faces â†’ group people',
                choose: 'Choose photo folder',
                browserHint: 'Use Chrome / Edge / Safari (Firefox may not support folder picking)',
                rebuild: 'Re-analyze',
                clear: 'Clear cache',
                engine: 'Engine',
                waiting: 'Waiting for upload...',
                folderNone: 'No folder selected',
                folderSelected: 'Selected folder:',
                thresholdHint: 'Adjust threshold (insightface higher = stricter; face_recognition lower = stricter):',
                thresholdLabel: 'Threshold',
                saveThreshold: 'Save threshold',
                smartGroups: 'Smart groups',
                emptyHint: 'No data yet. Choose a folder to start.',
                detailTitle: 'Person detail',
                back: 'â† Back to groups',
                statusLabel: 'Status',
                processingLabel: 'Processing',
                facesFound: 'Faces',
                noFace: 'No-face photos',
                personsPrefix: 'Person',
                photosUnit: 'photos',
                download: 'Download',
                downloadAll: 'Download all',
                downloading: 'Downloading...',
                downloadFailed: 'Download failed',
                parseFailed: 'Failed to parse response',
                uploadFailed: 'Upload failed',
                prepUpload: (n) => `Preparing to upload ${n} files...`,
                submittedBatch: (u, t) => `Submitted ${u}/${t}, queued...`,
                submittedAll: 'Submitted, analyzing...',
                errorPrefix: 'Error: ',
                rebuilding: 'Re-analyzing...',
                rebuildStarted: 'Re-analyze started',
                rebuildFailed: 'Re-analyze failed',
                clearing: 'Clearing cache...',
                cleared: 'Cache cleared, please upload again',
                clearFailed: 'Clear failed',
                thresholdSaved: 'Threshold saved, please re-analyze',
                thresholdInvalid: 'Invalid threshold',
                confirmClear: 'Clear cache (DB and copied photos)?',
                stateRunning: 'running',
                stateDone: 'done',
                stateIdle: 'idle',
                stateError: 'error'
            },
            zh: {
                title: 'Face Photo Search',
                subtitle: 'é€‰æ‹©ç…§ç‰‡æ–‡ä»¶å¤¹ â†’ è‡ªåŠ¨è¯†åˆ«äººè„¸ â†’ æŒ‰äººå½’ç±»',
                choose: 'é€‰æ‹©ç…§ç‰‡æ–‡ä»¶å¤¹',
                browserHint: 'æ¨èä½¿ç”¨ Chrome / Edge / Safariï¼ˆFirefox å¯èƒ½ä¸æ”¯æŒæ–‡ä»¶å¤¹é€‰æ‹©ï¼‰',
                rebuild: 'é‡æ–°åˆ†æ',
                clear: 'æ¸…ç©ºç¼“å­˜',
                engine: 'å½“å‰å¼•æ“',
                waiting: 'ç­‰å¾…ä¸Šä¼ ...',
                folderNone: 'æœªé€‰æ‹©æ–‡ä»¶å¤¹',
                folderSelected: 'å·²é€‰æ‹©æ–‡ä»¶å¤¹ï¼š',
                thresholdHint: 'è°ƒæ•´å½“å‰å¼•æ“çš„é˜ˆå€¼ï¼ˆinsightface è¶Šå¤§è¶Šä¸¥æ ¼ï¼›face_recognition è¶Šå°è¶Šä¸¥æ ¼ï¼‰ï¼š',
                thresholdLabel: 'å½“å‰é˜ˆå€¼',
                saveThreshold: 'ä¿å­˜é˜ˆå€¼',
                smartGroups: 'æ™ºèƒ½åˆé›†',
                emptyHint: 'è¿˜æ²¡æœ‰æ•°æ®ï¼Œè¯·å…ˆé€‰æ‹©ç…§ç‰‡æ–‡ä»¶å¤¹å¼€å§‹åˆ†æã€‚',
                detailTitle: 'äººç‰©è¯¦æƒ…',
                back: 'â† è¿”å›åˆé›†',
                statusLabel: 'çŠ¶æ€',
                processingLabel: 'æ­£åœ¨å¤„ç†',
                facesFound: 'å·²æœ‰äººè„¸',
                noFace: 'æ— äººè„¸',
                personsPrefix: 'äººç‰©',
                photosUnit: 'å¼ ',
                download: 'ä¸‹è½½',
                downloadAll: 'ä¸‹è½½å…¨éƒ¨',
                downloading: 'æ­£åœ¨ä¸‹è½½...',
                downloadFailed: 'ä¸‹è½½å¤±è´¥',
                parseFailed: 'è§£æå“åº”å¤±è´¥',
                uploadFailed: 'ä¸Šä¼ å¤±è´¥',
                prepUpload: (n) => `å‡†å¤‡ä¸Šä¼  ${n} ä¸ªæ–‡ä»¶...`,
                submittedBatch: (u, t) => `å·²æäº¤ ${u}/${t}ï¼Œæ­£åœ¨æ’é˜Ÿå¤„ç†...`,
                submittedAll: 'å·²æäº¤ï¼Œæ­£åœ¨åˆ†æ...',
                errorPrefix: 'é”™è¯¯: ',
                rebuilding: 'é‡æ–°åˆ†æä¸­...',
                rebuildStarted: 'å·²å¼€å§‹é‡æ–°åˆ†æ',
                rebuildFailed: 'é‡æ–°åˆ†æå¤±è´¥',
                clearing: 'æ­£åœ¨æ¸…ç†ç¼“å­˜...',
                cleared: 'ç¼“å­˜å·²æ¸…ç©ºï¼Œè¯·é‡æ–°ä¸Šä¼ ',
                clearFailed: 'æ¸…ç†å¤±è´¥',
                thresholdSaved: 'é˜ˆå€¼å·²æ›´æ–°ï¼Œè¯·é‡æ–°åˆ†æ',
                thresholdInvalid: 'é˜ˆå€¼æ ¼å¼ä¸æ­£ç¡®',
                confirmClear: 'ç¡®å®šæ¸…ç©ºç¼“å­˜ï¼ˆæ•°æ®åº“å’Œå·²å¤åˆ¶çš„ç…§ç‰‡ï¼‰å—ï¼Ÿ',
                stateRunning: 'è¿è¡Œä¸­',
                stateDone: 'å®Œæˆ',
                stateIdle: 'ç©ºé—²',
                stateError: 'é”™è¯¯'
            }
        };

        function t(key) {
            return i18n[currentLang][key] ?? key;
        }

        function applyLanguage() {
            document.documentElement.lang = currentLang === 'zh' ? 'zh-CN' : 'en';
            titleText.textContent = t('title');
            subtitleText.textContent = t('subtitle');
            chooseBtn.textContent = `ğŸ“ ${t('choose')}`;
            browserHint.textContent = t('browserHint');
            rebuildBtn.textContent = `ğŸ”„ ${t('rebuild')}`;
            clearBtn.textContent = `ğŸ—‘ï¸ ${t('clear')}`;
            enginePill.textContent = `${t('engine')}: ${currentEngine || ''}`;
            statusText.textContent = t('waiting');
            floatingLabel.textContent = t('statusLabel');
            floatingText.textContent = t('waiting');
            folderPathEl.textContent = t('folderNone');
            thresholdHint.textContent = t('thresholdHint');
            thresholdPill.firstChild.textContent = `${t('thresholdLabel')}: `;
            saveThresholdBtn.textContent = `ğŸ’¾ ${t('saveThreshold')}`;
            groupsTitle.textContent = t('smartGroups');
            emptyHint.textContent = t('emptyHint');
            detailTitle.textContent = t('detailTitle');
            backBtn.textContent = t('back');
            downloadPhotoBtn.textContent = `â¬‡ï¸ ${t('download')}`;
            downloadAllBtn.textContent = `â¬‡ï¸ ${t('downloadAll')}`;
            langEnBtn.classList.toggle('active', currentLang === 'en');
            langZhBtn.classList.toggle('active', currentLang === 'zh');
        }

        langEnBtn.onclick = () => { currentLang = 'en'; applyLanguage(); loadGroups(); };
        langZhBtn.onclick = () => { currentLang = 'zh'; applyLanguage(); loadGroups(); };

        input.addEventListener('change', async (e) => {
            if (!e.target.files.length) return;
            const files = Array.from(e.target.files);
            const folder = files[0].webkitRelativePath ? files[0].webkitRelativePath.split('/').slice(0, -1).join('/') : '(è‡ªå®šä¹‰é€‰æ‹©)';
            folderPathEl.textContent = `${t('folderSelected')} ${folder || ''}`.trim();
            const batchSize = 40; // æ§åˆ¶å•æ¬¡è¯·æ±‚ä½“ç§¯ï¼Œé¿å…è§£æå¤±è´¥
            setStatus(t('prepUpload')(files.length), 0, files.length);
            let uploaded = 0;
            try {
                for (let i = 0; i < files.length; i += batchSize) {
                    const slice = files.slice(i, i + batchSize);
                    const formData = new FormData();
                    slice.forEach(f => formData.append('files', f, f.webkitRelativePath || f.name));
                    const res = await fetch('/api/upload-folder', {
                        method: 'POST',
                        body: formData
                    });
                    let data = null;
                    try {
                        data = await res.json();
                    } catch (_) {
                        const bodyText = await res.text();
                        throw new Error(bodyText || t('parseFailed'));
                    }
                    if (!res.ok) throw new Error(data.detail || data.message || t('uploadFailed'));
                    uploaded += slice.length;
                    setStatus(t('submittedBatch')(uploaded, files.length), uploaded, files.length);
                }
                setStatus(t('submittedAll'), files.length, files.length);
                startPolling();
            } catch (err) {
                setStatus(t('errorPrefix') + err.message, 0, 1, true);
            } finally {
                input.value = '';
            }
        });

        function setStatus(text, value, max, isError=false) {
            statusText.textContent = text;
            statusText.style.color = isError ? '#fecdd3' : 'var(--muted)';
            progressBar.value = value;
            progressBar.max = Math.max(max, 1);
            floatingText.textContent = text;
            floatingProgress.value = value;
            floatingProgress.max = Math.max(max, 1);
        }

        async function pollStatus() {
            try {
                const res = await fetch('/api/status');
                const data = await res.json();
                const { state, total, processed, current, faces_found, photos_no_face } = data;
                if (total > 0) {
                    progressBar.max = total;
                    progressBar.value = processed;
                }
                const stateLabel = {
                    running: t('stateRunning'),
                    done: t('stateDone'),
                    idle: t('stateIdle'),
                    error: t('stateError')
                }[state] || state;
                let line = `${t('statusLabel')}: ${stateLabel}`;
                if (state === 'running') {
                    line += ` Â· ${processed}/${total} Â· ${t('processingLabel')}: ${current || '...'}`;
                }
                line += ` Â· ${t('facesFound')}: ${faces_found || 0}`;
                if (photos_no_face) line += ` Â· ${t('noFace')}: ${photos_no_face}`;
                setStatus(line, progressBar.value, progressBar.max);

                if (state === 'done' || state === 'idle') {
                    await loadGroups();
                }
                if (state === 'error') {
                    setStatus(t('errorPrefix') + (data.error || ''), 0, 1, true);
                    stopPolling();
                }
            } catch (e) {
                console.warn(e);
            }
        }

        function startPolling() {
            if (pollTimer) clearInterval(pollTimer);
            pollTimer = setInterval(pollStatus, 1000);
            pollStatus();
        }
        function stopPolling() {
            if (pollTimer) clearInterval(pollTimer);
            pollTimer = null;
        }

        async function loadGroups() {
            const res = await fetch('/api/groups');
            const data = await res.json();
            const groups = data.groups || [];
            groupGrid.innerHTML = '';
            if (!groups.length) {
                emptyHint.classList.remove('hidden');
                groupGrid.classList.add('hidden');
                return;
            }
            emptyHint.classList.add('hidden');
            groupGrid.classList.remove('hidden');
            groups.forEach((g, idx) => {
                const label = `${t('personsPrefix')} ${idx + 1}`;
                const card = document.createElement('div');
                card.className = 'person-card';
                card.innerHTML = `
                    <img class="avatar" src="/api/face-cover/${g.group_id}?w=256" alt="cover">
                    <div class="card-title">${label}</div>
                    <div class="card-sub">${g.photo_count || g.count || 0} ${t('photosUnit')}</div>
                `;
                card.onclick = () => loadGroupDetail(g.group_id, label);
                groupGrid.appendChild(card);
            });
        }

        async function loadGroupDetail(groupId, label) {
            const res = await fetch(`/api/groups/${groupId}`);
            if (!res.ok) return;
            const data = await res.json();
            const photos = data.photos || [];
            detailGrid.innerHTML = '';
            currentGroupId = groupId;
            photos.forEach(pid => {
                const img = document.createElement('img');
                img.className = 'thumb';
                img.src = `/api/photo/${pid}?w=256`;
                img.onclick = () => {
                    currentPhotoId = pid;
                    showModal(`/api/photo/${pid}`);
                };
                detailGrid.appendChild(img);
            });
            detailTitle.textContent = `${label || t('personsPrefix')} Â· ${photos.length} ${t('photosUnit')}`;
            detailSection.classList.remove('hidden');
            detailSection.scrollIntoView({behavior: 'smooth'});
        }

        backBtn.onclick = () => {
            detailSection.classList.add('hidden');
        };

        function showModal(src) {
            modalImg.src = src;
            // store full-size url for download
            modal.classList.remove('hidden');
            modal.style.display = 'flex';
        }
        modal.onclick = () => {
            modal.classList.add('hidden');
            modal.style.display = 'none';
            modalImg.src = '';
        };

        rebuildBtn.onclick = async () => {
            setStatus(t('rebuilding'), 0, 1);
            rebuildBtn.disabled = true;
            try {
                const res = await fetch('/api/rebuild', { method: 'POST' });
                const data = await res.json();
                if (!res.ok) throw new Error(data.detail || data.message || t('rebuildFailed'));
                setStatus(data.message || t('rebuildStarted'), 0, 1);
                startPolling();
            } catch (err) {
                setStatus(t('errorPrefix') + err.message, 0, 1, true);
            } finally {
                rebuildBtn.disabled = false;
            }
        };

        thresholdInput.addEventListener('input', () => {
            thresholdValue.textContent = thresholdInput.value;
        });

        async function loadSettings() {
            try {
                const res = await fetch('/api/settings');
                const data = await res.json();
                if (res.ok) {
                    const key = currentEngine === 'face_recognition' ? 'facerec_threshold' : 'insightface_threshold';
                    const v = data[key];
                    thresholdInput.value = v;
                    thresholdValue.textContent = v;
                }
            } catch (e) {
                console.warn(e);
            }
        }

        async function saveThreshold() {
            const val = parseFloat(thresholdInput.value);
            if (Number.isNaN(val)) throw new Error(t('thresholdInvalid'));
            const payload = new URLSearchParams({ engine: currentEngine, value: String(val) });
            const res = await fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: payload
            });
            let data = null;
            try { data = await res.json(); } catch (_) {}
            if (!res.ok) {
                let msg = data?.detail || data?.message;
                if (Array.isArray(msg)) {
                    msg = msg.map(d => d?.msg || JSON.stringify(d)).join('; ');
                }
                throw new Error(msg || t('errorPrefix'));
            }
            setStatus(t('thresholdSaved'), 0, 1);
        }

        document.getElementById('saveThreshold').onclick = async () => {
            try {
                await saveThreshold();
            } catch (err) {
                setStatus(t('errorPrefix') + err.message, 0, 1, true);
            }
        };

        clearBtn.onclick = async () => {
            if (!confirm(t('confirmClear'))) return;
            setStatus(t('clearing'), 0, 1);
            try {
                const res = await fetch('/api/clear-cache', { method: 'POST' });
                const data = await res.json();
                if (!res.ok) throw new Error(data.detail || data.message || t('clearFailed'));
                setStatus(data.message || t('cleared'), 0, 1);
                await loadGroups();
            } catch (err) {
                setStatus(t('errorPrefix') + err.message, 0, 1, true);
            }
        };

        downloadPhotoBtn.onclick = (e) => {
            e.stopPropagation();
            if (!currentPhotoId) return;
            const url = `/api/photo/${currentPhotoId}?download=1`;
            const a = document.createElement('a');
            a.href = url;
            a.download = '';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        };

        downloadAllBtn.onclick = async () => {
            if (!currentGroupId) return;
            setStatus(t('downloading'), 0, 1);
            try {
                const res = await fetch(`/api/groups/${currentGroupId}/zip`);
                if (!res.ok) {
                    const data = await res.json().catch(() => ({}));
                    throw new Error(data.detail || data.message || t('downloadFailed'));
                }
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `group_${currentGroupId.slice(0,6)}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                setStatus(t('waiting'), 0, 1);
            } catch (err) {
                setStatus(t('errorPrefix') + err.message, 0, 1, true);
            }
        };

        modalContent.addEventListener('click', (e) => e.stopPropagation());

        // initial load
        applyLanguage();
        loadGroups();
        loadSettings();
        // ensure modal stays hidden on first paint
        modal.classList.add('hidden');
        modal.style.display = 'none';
    </script>
</body>
</html>
